\chapter{Программная реализация} \label{ch:programm}
В предыдущей главе была составлена общая абстрактная модель имитации, в этой же главе будет описана её реализация.
Для написания программы был выбран язык C++, в качестве библиотеки графического интерфейса -- Qt.
Объектноориентированный стиль программы хорошо подошёл для поставленной задачи. 
Во-первых, в программе сами собой напрашиваются многие объекты: РЛС, спутник и пр., во-вторых, между ними хорошо
строятся наследственные связи (это будет показано далее по тексту), а в-третьих, объектно-ориентированный подход
позволил спроектировать программу таким образом, чтобы любой её модуль или даже часть модуля
можно было легко заменить или сделать несколько реализаций.

\section{Общая информация}

Программа разделена на четыре основные части:
\begin{itemize}
	\item Библиотека для иммитации и восстановления параметров орбиты по результатам наблюдений, содержащую в
			себе всю логику относящуюся к симулированию радионаблюдений, реализацию всех необходимых для этого
			моделей из предыдущей главы и прикладные модули, необходимые для
			нормальной работы.
	\item Библиотека для работы с методом градиентного спуска и методом наименьших квадратов.
	\item Графический интерфейс, позволяющий удобно использовать написанную программу.
	\item Текстовый постпроцессор, позволяющий выгружать данные для обработки в других программах.
\end{itemize}

Читая текст работы может создаться впечатление, что архитектура программы была спроектирована заранее (т.к.
изложение идёт от постановки задачи к её реализации модуль за модулем), но это совсем не так. Программа множество
раз меняла свою структуру, реализацию, архитектуру и пр., по мере улучшения понимания поставленной задачи и её
теоретических аспектов. Однако не все части программы переписывались, для идеального вписывания в новую архитектуру,
из-за этого некоторые функции могут не использоваться, классы могли получится перегруженными или наоборот --
слишком разряженными, API местами неудобным и т.д. Всё это результат многократного рефакторинга. 
Кончено, в будущем все такие недостатки можно исправить.
\newpage

\section{Иммитатор радиоизмерений}

\begin{wrapfigure}[22]{l}{0.4\textwidth}
	\begin{center}
		\input{graphs/control-flow-scheme}
	\end{center}
	\caption{Граф потока управления иммитатора} \label{fig:control-flow-scheme}
\end{wrapfigure}
Первым делом, необходимо оговорить детали реализации иммитатора, иммитатор разделён на следующие подмодули
реализующие абстрактные модели (см. рисунок \ref{common-immitation-scheme}):
\begin{itemize}
	\item OrbitCalculator, модуль расчёта орбит спутников -- реализация модели движения КО.
	\item NeQuick, модуль расчёта влияния ионосферы -- реализация модели влияния ионосферы.
	\item RadarStation, модуль отвечающий за логику самой РЛС и проводимые её измерения -- реализация модели выбора
			КО и модели радиолокационных измерений, здесь же будет вноситься случайнаz ошибка измерений.
\end{itemize}

Так же в иммитатор входит \textit{ImmitationDriver} управляющий модуль, запускает и управляет циклами имитации,
направляет и именует потоки данных, может взаимодействовать с пользователем или внешними модулями и т.д

\subsection{Цикл имитации}

Определив все модули программы, можно определить то, как будет выглядеть один цикл вычислений, т.е. проведение
одного измерения радиолокационной станцией в определённый момент времени. Блок-схемы потока управления и потока
данных представлены на рисунке \ref{fig:control-flow-scheme} и \ref{fig:data-flow-scheme}.
\begin{figure}[H]
	\centering
	\input{graphs/data-flow-scheme}
	\caption{Граф потока данных иммитатора} \label{fig:data-flow-scheme}
\end{figure}

\textit{ImmitationDriver} занимается управлением циклами и слежением за тем, чтобы во время каждого цикла модулям
были доступны соответствующие этому циклу данные. \textit{TLEReader} в практической реализации не участвует в каждом 
цикле -- \textit{OrbitCalculator} обращается к нему только на первой итерации, для получения списка спутников 
и их параметров.

\subsection{Классы и диаграмма классов}

Как уже говорилось ранее, основные объекты, участвующие в имитации, хорошо и удобно объявляются в виде классов. В
модуле иммитации определены следующие классы:
\begin{mydef} \label{typ:GeoPoint}
Тип \textbf{GeoPoint} -- Класс для представления координат любых объектов в географической системе координат. 
Имеет методы \textit{GetLatitude}, \textit{GetLongitude}, \textit{GetAltitude}, \textit{DistanceTo} для получения соответственно широты, долготы, высоты и расстояния до любой другой заданной точки.
\end{mydef}
\begin{mydef} \label{typ:OrbitPoint}
Тип \textbf{OrbitPoint} -- Класс для представления координат любых объектов находящихся на орбите Земли 
в прямоугольной не вращающейся вместе с Землёй системе координат. Является наследником класса GeoPoint 
(см. Определение \ref{typ:GeoPoint})
Имеет методы \textit{GetIntertialX}, \textit{GetIntertialY}, \textit{GetIntertialZ} для получения 
координат x, y и z. А также метод \textit{GetTime} для получения момента времени в который спутник находился в 
указанных координатах.
\end{mydef}
\begin{mydef} \label{typ:RadarStation}
Тип \textbf{RadarStation} -- Класс для представления координат РЛС и её параметров. Является наследником класса 
GeoPoint (см. Определение \ref{typ:GeoPoint})
Имеет методы \textit{GetWorkFrequency} для получения рабочей частоты радара, \textit{IsInSigh} -- для получения
информации о том, попадает, переданная в качестве аргумента метода, точка в зону обнаружения РЛС (т.е. видит ли РЛС
эту точку), \textit{ObservedDistanceTo} для вычисления измеряемого расстояния до точки (т.е. с учётом ионосферы)
координат x, y и z. А также методы \textit{ZenithAngleTo} и \textit{AzimuthAngleTo} для получения углов наблюдения 
точки с учётом влияния ионосферы.
\end{mydef}

Вызов любого из методов: \textit{ObservedDistanceTo}, \textit{ZenithAngleTo} или \textit{AzimuthAngleTo}, фактически
приводит к запуску одной итерации цикла иммитации (см. рисунок \ref{fig:control-flow-scheme}).

Кроме этого в модуле есть классы для работы с орбитами, которые могут содердать в себе множество точек типа 
\textit{OrbitPoint} (\ref{typ:OrbitPoint}):
\begin{mydef} \label{typ:Orbit}
Тип \textbf{Orbit} -- Класс для представления орбиты спутника и её параметров. Позволяет вычислить и сохранить
местоположения спутника в указанные моменты времени. Вызов любого из его методов -- \textit{GetTrajectoryPoint} 
или \textit{GetTrajectoryPoints} запустит иммитацию по модели SDP/SGP (см. параграф \ref{sbs:space-object-model}).
\end{mydef}

Для сохранения результатов иммитации создан специальный класс \textit{SightReport}
\begin{mydef} \label{typ:SightReport}
Тип \textbf{SightReport} -- Класс представляющий из себя отчёт о наблюдении одной РЛС.в один момент времени
Сохраняет координаты наблюдения, время и параметры наблюдавшей РЛС, а так же истинные значения всех величин.
\end{mydef}

Из определений видно, что \textit{RadarStation} и \textit{OrbitPoint} наследуются от GeoPoint, таким образом, удаётся
добиться простоты в расчётах расстояния и координат для них. Для точек орбит функции GetLatitude, GetLongitude будут 
возвращать координаты подспутниковой точки.

Схем классов слегка отличаются от тех, что были составлены для модулей иммитатора, главным образом в целях оптимизации производительности и читаемости кода.

Полностью описать работу иммитатора можно блок-схемой изображённой на рисунке \ref{}